#summary Description of the PageFactory in the WebDriver support library.

= The PageFactory =

In order to support the PageObject pattern, WebDriver's support library contains a factory class.

== A Simple Example ==

In order to use the PageFactory, first declare some fields on a PageObject that are WebElements or RenderedWebElements, for example:

{{{
package com.thoughtworks.webdriver.example;

import com.thoughtworks.webdriver.WebElement;

public class GoogleSearchPage {
    // Here's the element
    private WebElement q;

    public void searchFor(String text) {
        // And here we use it. Note that it looks like we've
        // not properly instantiated it yet....
        q.setValue(text);
        q.submit();
    }
} 
}}}

In order for this code to work and not through a NullPointerException because the "q" field isn't instantiated, we need to initialise the PageObject:

{{{
package com.thoughtworks.webdriver.example;

import com.thoughtworks.webdriver.WebDriver;
import com.thoughtworks.webdriver.WebElement;
import com.thoughtworks.webdriver.htmlunit.HtmlUnitDriver;
com.thoughtworks.webdriver.support.PageFactory;

public class UsingGoogleSearchPage {
    public static void main(String[] args) {
        // Create a new instance of a driver
        WebDriver driver = new HtmlUnitDriver();

        // Navigate to the right place
        driver.get("http://www.google.com/");

        // Create a new instance of the search page class
        // and initialise any WebElement fields in it.
        GoogleSearchPage page = PageFactory.initElements(driver, GoogleSearchPage.class);

        // And now do the search.
        page.searchFor("Cheese");
    }
} 
}}}

=== Explanation ===

The PageFactory relies on using sensible defaults: the name of the field in the Java class is assumed to be the "id" of the element on the HTML page. That is, in the example above, the line:

{{{ 
    q.setValue(text);
}}}

is equivalent to:

{{{
    driver.findElement(By.id("q")).setValue(text);
}}}

The driver instance that's used is the one that's passed to the PageFactory's initElements method.

In the example given, we rely on the PageFactory to instantiate the instance of the 
PageObject. It does this by first looking for a constructor that takes "WebDriver" as it's sole argument ({{{public SomePage(WebDriver driver) {}}}}) If this is not present, then the default constructor is called. Sometimes, however, the PageObject depends on more than just an instance of the WebDriver interface. Should this be the case, it is possible to get the PageFactory to initialise the element's of an already constructed object:

{{{
ComplexPageObject page = new ComplexPageObject("expected title", driver);

// Note, we still need to pass in an instance of driver for the 
// initialised elements to use
PageFactory.initElements(driver, page);
}}}

== Making the Example Work Using Annotations ==

Sadly, when we run the example code above a {{{NoSuchElementException}}} is thrown. This is obviously not right, and happens because there is no element who's ID is "q" on the Google home page. Fortunately, we can change the strategy used to look the element up using an annotation:

{{{
package com.thoughtworks.webdriver.example;

import com.thoughtworks.webdriver.By;
import com.thoughtworks.webdriver.How;
import com.thoughtworks.webdriver.support.FindBy;
import com.thoughtworks.webdriver.WebElement;

public class GoogleSearchPage {
    // The element is now looked up using an XPath expression
    @FindBy(how = How.XPATH, using = "//input[@name='q']")
    private WebElement q;

    public void searchFor(String text) {
        // We continue using the element just as before
        q.setValue(text);
        q.submit();
    }
} 
}}}

One wrinkle that remains is that every time we call a method on the WebElement, the driver will go and find it on the current page again. In an AJAX-heavy application, this is what you would like to happen, but in the case of the Google search page, we know that the element is always going to be there, and won't change. We also know that we won't be navigating away from the page and returning (which would mean that a different element with the same name would be present) It would be handy if we could "cache" the element once we'd looked it up:

{{{

package com.thoughtworks.webdriver.example;

import com.thoughtworks.webdriver.By;
import com.thoughtworks.webdriver.How;
import com.thoughtworks.webdriver.support.CacheLookup;
import com.thoughtworks.webdriver.support.FindBy;
import com.thoughtworks.webdriver.WebElement;

public class GoogleSearchPage {
    // The element is now looked up using an XPath expression,
    // and we never look it up once it has been used the first time
    @FindBy(how = How.XPATH, using = "//input[@name='q']")
    @CacheLookup
    private WebElement q;

    public void searchFor(String text) {
        // We continue using the element just as before
        q.setValue(text);
        q.submit();
    }
} 
}}}

== Notes ==

  * If you use the PageFactory, you can assume that the fields are initialised. If you don't use the PageFactory, then NullPointerExceptions will be thrown if you make the assumption that the fields are already initialised.
  * WebElements are evaluated lazily. That is, if you never use a WebElement field in a PageObject, there will never be a call to "findElement" for it.
  * The functionality works using dynamic proxies. This means that you shouldn't expect a WebElement to be a particular subclass, even if you know the type of the driver. For example, if you are using the HtmlUnitDriver, you shouldn't expect the WebElement field to be initialised with an instance of HtmlUnitWebElement.