#summary How the ChromeDriver works
#labels WebDriver

=ChromeDriver Internals=

The ChromeDriver is largely written in the form of a Chrome extension [http://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/extensions/docs/index.html (API details)].  The language bindings listen on a socket for the extension to initialise events, and requests and responses are sent over this port.  The extension comprises of a background page (which is loaded when the first window of the browser first opens, and remains open until the last window o the browser closes), which handles the HTTP communication.  Also, a content script, which loads in the context of every page which loads, and allows interaction with the DOM, and an NPAPI plugin, which allows for native events.

==Working on the ChromeDriver code==

Firstly, if you are on Windows, make sure that Win32/Debug/npchromedriver.dll has been compiled.  It is deleted when you {{{rake clean}}}.  If it is not present, compile it.

Secondly, take a look at the [http://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/extensions/docs/index.html Chrome Extensions pages] to get to grips with the flow of extensions.  They have a very simple and clean API (they look just like standard HTML and Javascript), but a little background is useful.  Now you should be able to get hacking.  It's best to create a test around the area of code that you're working on, and to run this using the SingleTestSuite.  To use the ChromeDriver from an IDE as opposed to from JARs, you should use the org.openqa.selenium.chrome.ChromeDriverTestSuite$TestChromeDriver rather than the org.openqa.selenium.chrome.ChromeDriver, the difference being that the latter loads its extension from a zip file in the JAR, whereas the former uses the files in chrome/src/extension.

Some useful debugging information is dumped in the Chrome window itself.  To access this, stop the Chrome process from being terminated (perhaps comment out the chromeProcess.destroy(); line in org.openqa.selenium.chrome.ChromeBinary) and look at the inspector console.  For the content script, the can be found by pressing Ctrl + Shift + J on the page which is loaded.  For the background page, this can be found by navigating in a new tab to chrome://extensions and clicking on inspect, next to Background Page.  The console can be accessed by pressing the button which looks a bit like >= at the bottom.  You can use this console to execute arbitrary javascript in the relevant pages, but note that any javascript executed in the page will be executed in the page, NOT the content script.  There is currently no way of accessing the content script's context in Chrome.  You can call console.log(foo) within the content script to dump to the log, which will work for objects as well as strings.

==Flow of Control: Starting Chrome==

The language bindings need to listen on an arbitrary TCP port.  They should serve a minimal static HTML page in response to any GET requests, and parse any POST requests as below.  When the bindings are listening on the TCP port, they need to run an instance of Chrome, with the extension loaded and send it to the a page which will send a GET to the bindings' port.  Chrome should be launched with a new profile each run - currently this is just an empty folder with a blank text file called "First Run Dev" in it - this may change.

e.g. {{{chrome.exe --load-extension="path/to/extension" --use-user-dir="path/to/profile" http://localhost:1234}}}

Note: Henceforth, I will refer to TCP port if I mean the port between the language bindings and the extension, and just port if I mean a chrome extensions communication port between a content script and the background page.

The following steps are performed when Chrome loads:

 # The background page is loaded.  It sits listening for a content script to open a port to it.
 # The page passed to Chrome is loaded.  When it is fully loaded, its content script opens a port to the background page.
 # The background page grabs the URL from the content script's port and sends a POST XmlHttpRequest to that URL.  This POSTs over the TCP port.  The language bindings receive this, and interpret it as a statement of readyness for a command.
 # The bindings are given a command to execute by the test case.  This is sent as the response to the XmlHttpRequest.
 # The background page parses this response (containing a command), and either comes up with a response itself, or sends a message the the content script requesting action, and parses the response to this request for action into a response.  It then sends this response as the POST data of a new XmlHttpRequest.
 # The language bindings listen for this POST, parse the POST data, return it to the test as the result of the command, and leaves the XmlHttpRequest hanging, so that it can send the next command as the response to it.

Communication over the TCP port is JSON over HTTP.  Commands are of the form: {{{{request: 'findElement', by: ["id", "foo"]}}}} and responses of the form {{{{response: 'findElement', value: {statusCode: 0, elementId: "element/0"}}}}}.  The commands are loosely based on the JsonWireProtocol, and are enumerated in org.openqa.selenium.chrome.ChromeCommandExecutor.  All HTTP status codes should be 200.  In the JSON responses, a statusCode of 0 indicates success.  A non-zero statusCode indicates an exception of some kind.  Exceptions may optionally have message attributes along with them, to give debugging information.

Communication between the background page and content script uses an identical protocol, with the addition of the "no-op" statusCode.  Generally, the content script sends the background page a response which is ready to be returned to the language bindings.  If more action is required from the background page (e.g. sending keys is a multi-stage process - first the background page tells the content script to focus on an element, then the content script tells the background page it has done this, and should make a native call - this response has a "no-op" statusCode, because it should not directly return to the language bindings.  Messages between the background page and content script are wrapped in an object which contains a sequence number, which is unique per invocation of the ChromeDriver: {{{{request: requestObject, sequenceNumber: 0}}}} and {{{{response: responseObject, sequenceNumber: 0}}}}.  The content script ignores any sequence number <= the last one it processed.

==How pages are loaded (actually quite tricky)==
Loading pages is a really easy task.  Unless you have frames, or ever change pages other than by driver.get(url).  Then it's really awkward.

When calling driver.get(url), we check if we currently have a tab.  If we don't, we create a new one at the correct URL.  If we do, we check if we're currently on a page which has the same location other than fragment as where we're going.  If so, we update the tab to go to the new location - *we preserve the same content script*.  If not, we close our existing tab, and open a new one at the correct URL.  We do this for good reasons, which I can't entirely remember.  There really is a good reason, though.  Honest.

So what happens when a page is loaded? Firstly, a content script is loaded.  The first thing the content script does is open a port to the background page.  The background page listens out for these.

The easy case is where there are currently no pages loaded, and the page loading has no frames or iframes.  Oh, and the page isn't going to redirect anywhere (by meta, or perhaps javascript).  In this case, the background page goes "Ooh! A new page! Hurrah!" and adds an object encapsulating the tab, port, and general features of relevance, along with an empty array of frames, in ChromeDriver.tabs.  Because there aren't any other pages, ChromeDriver.doFocusOnNextOpenedTab happens to be set to true, so we also set the active port and active tab to be the new one.  We're now ready to go, easy.  When this tab is closed, the onDisconnect will fire, and we will remove the relevant things from the relevant variables, and set the relevant state.  Easy.  Well, not quite.  When the content script connects to the background page, it also sends a newTabInformation message, but we'll worry about that when we get to frames.  Also, when the background page sees that the tab has loaded, it sends a sniffForMetaRedirects message, which asks the content script to report whether it's about to change to a new URL, and delays believing that the tab has loaded until it's told that there are no meta redirects.

In case that page does go away, we also buffer the last request we sent, in ChromeDriver.lastRequesToBeSentWhichHasntBeenAnsweredYet.  If we connect to a new tab, and it seems to be the only tab there (e.g. when we load a tab, it redirects, which closes the port, and we get to the new location, so a new port is opened), we check if we have a buffered request, and if we do, we re-send it.

That wasn't too bad, right?  Well, that was the easy case.  I also mostly summed up what happens if you change url other that driver.get()ing.  Although, I'll throw in that if you driver.get(url) somewhere new which is only fragment-different, we send our "Success" response when the tab is finished loading, rather than when a new content script connects, because we preserve the content script when we're on the same page.

So, frames...  Frames are veritably the devil.  Each new frame has its own content script, so opens a new port when it loads.  Thankfully, the frameset's content script always loads before any subframe's.  Frames load in the same tab as their frameset.  So when a content script connects, the background page check ChromeDriver.tabs to see if any have the same tab id.  If they do, this is a frame, so we push it in the frames list for that ChromeDriver.tabs entry.

I said I'd mention newTabInformation! Well, this message contains several fields.  Firstly, it has an isFrameset field, and a frameCount field - this is so that if the page is a frameset, we wait until we have been connected to by frameCount more content scripts before we report the page has having loaded.  Otherwise, we would do so preemptively, and this would be bad.  We also report the port name (which happens to be equal to window.name).  This is so that if the message is coming from a frame, we know what it is called, so we can switch to it.  This is useful, because Chrome does not yet support accessing window.frames from extensions.  Track [http://code.google.com/p/chromium/issues/detail?id=20773 Chrome Bug 20773] to know when this may be fixed.

ChromeDriver.activePort always points at the active frame we are using, be that to a frame or a frameset (note that when we load a frameset, defaultContent is the 0th frame, so we shouldn't ever really be pointing at a frameset, but we may be pointing at a page which contains an iframe, which is a similar situation).  ChromeDriver.activeTabId always contains the ID of the tab we are currently in communication with (or null if there is none).  This is useful, because we can always access a frameset by looking up in ChromeDriver.tabs for the tab which has the id ChromeDriver.activeTabId, and grabbing that port (for instance, if we need to resolve a frame positional number to its name).  This port is conveniently stored in ChromeDriver.portToUseForFrameLookups.

Oh, and on top of that, we have no way of knowing if content scripts are connecting from top-level frames, or nested frames, if we have nested frames.  And they don't happen in a predictable order.  So we cross our fingers and hope that no two frame hierarchies in the same tab contain a frame with the same name, and behaviour is undefined if they do.

==Native events==

Native events are handled by an NPAPI plugin.  This plugin, with MIME-type application/x-webdriver is embedded in the background page, so loaded as soon as the browser loads.  This plugin will listen out for javascript calls on it (document.embeds[0].foo()), and reacts to them (see chrome/src/cpp/npchromedriver/npapi_hooks.h for the supported functions).  In order to interact with a page in the browser, the first time a native event is executed in a page, a plugin with MIME-type application/x-webdriver-reporter (also handled by the same NPAPI plugin) is embedded in the page, by the content script (see the handling of the "injectEmbed" command, which is called using the wrapInjectEmbedIfNecessary method in the background page).  The NPAPI plugin listens out for this embed, and when it appears present, grabs the window handle of the page it has been injected into.  All native events will be sent to that window handle, until a new application/x-webdriver-reporter is embedded, which will overwrite the old window handle in internal state.

==Contact information==
ChromeDriver was written by DanielWagnerHall as an internship project at Google.  If you feel this page is missing anything, or need any help hacking with the ChromeDriver, feel free to get in touch: dawagner-AT-gmail-DOT-com