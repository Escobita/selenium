#summary WebDriver FAQs
#labels Featured,WebDriver

= FAQ =

<wiki:toc max_depth="3" />

=== Q: What is WebDriver? ===

A: WebDriver is a tool for writing automated tests of websites. It aims to mimic the behaviour of a real user, and as such interacts with the HTML of the application.

=== Q: So, is it like [http://www.openqa.org/selenium-core/ Selenium]? Or [http://sahi.co.in/ Sahi]? ===

A: The aim is the same (to allow you to test your webapp), but the implementation is different. Rather than running as a Javascript application within the browser (with the limitations this brings, such as the "[http://www.openqa.org/selenium-rc/tutorial.html same origin]" problem), WebDriver controls the browser itself. This means that it can take advantage of any facilities offered by the native platform.

=== Q: What is Selenium 2.0? ===

A: WebDriver will soon become part of [http://www.openqa.org/selenium Selenium]. The main contribution that WebDriver will make is its API and the native drivers. The process of rolling WebDriver into Selenium will probably take some time, so until it's complete if you'd like to use the WebDriver API then the best bet will be to use WebDriver directly. There's an introduction to this at the [http://google-opensource.blogspot.com/2009/05/introducing-webdriver.html Google Open Source blog].

=== Q: What's the plan for migrating WebDriver into Selenium? ===

A: The process is being discussed on the [http://clearspace.openqa.org/message/48227#48227 OpenQA forum], but the current plan is that parts of WebDriver will be rolled into Selenium 1.5. For the user, the key change will be that the WebDriver interfaces will become available within the Selenium (RC) libraries. There will also be a series of changes internally, for example picking the WebDriver implementation of the Selenium interfaces where this is appropriate, and these changes will be discussed and tracked on the OpenQA site and/or the [http://groups.google.com/group/webdriver?pli=1 WebDriver mailing list].

=== Q: What does it mean to be "developer focused"? ===

A: We believe that within a software application's development team, the people who are best placed to build the tools that everyone else can use are the developers. Although it should be easy to use WebDriver directly, it should also be easy to use it as a building block for more sophisticated tools. Because of this, WebDriver has a small API that's easy to explore by hitting the "autocomplete" button in your favourite IDE, and aims to work consistently no matter which browser implementation you use.

=== Q: How do I execute Javascript directly? ===

A: We believe that most of the time there is a requirement to execute Javascript there is a failing in the tool being used: it hasn't emitted the correct events, has not interacted with a page correctly, or has failed to react when an XmlHttpRequest returns. We would rather fix WebDriver to work consistently and correctly than rely on testers working out which Javascript method to call.

We also realise that there will be times when this is a limitation. As a result, for those browsers that support it, you can execute Javascript by casting the WebDriver instance to a [http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/JavascriptExecutor.html JavascriptExecutor]. In Java, this looks like:

{{{
WebDriver driver; // Assigned elsewhere
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("return document.title");
}}}

Other language bindings will follow a similar approach. Take a look at the UsingJavascript page for more information.

=== Q: Why is my Javascript execution always returning null? ===

A: You need to return from your javascript snippet to return a value, so:

{{{
js.executeScript("document.title");
}}}

will return null, but:

{{{
js.executeScript("return document.title");
}}}

will return the title of the document.

=== Q: Which browsers does WebDriver support? ===

A: The existing drivers are the ChromeDriver, InternetExplorerDriver, FirefoxDriver and HtmlUnitDriver. For more information about each of these, including their relative strengths and weaknesses, please follow the links to the relevant pages.

=== Q: My XPath finds elements in one browser, but not in others. Why is this? ===

A: The short answer is that each supported browser handles XPath slightly differently, and you're probably running into one of these differences. The long answer is on the XpathInWebDriver page.

=== Q: The InternetExplorerDriver does not work well on Vista. How do I get it to work as expected? ===

A: There are a number of solutions:
   * Add any domains the browser visits to IE's "trustworthy sites". If you use a large number of sites, this might be problematic, so think about using a wild card (though only if you don't use IE as your main browser!)
   * Run Java with Administrator rights. Note, that this is potentially a large security hole: only visit sites you trust when running in this mode.

The second approach is required when using IE8 and Vista or above.

=== Q: What about support for languages other than Java? ===

A: Python and Ruby support are already available. Support for C# is planned, and we will be announcing this on the mailing list as they are checked in. There is also a Javascript API (JS API) which is available on Firefox. 

=== Q: How do I handle pop up windows? ===

A: WebDriver offers the ability to cope with multiple windows. This is done by using the "WebDriver.switchTo().window()" method to switch to a window with a known name. If the name is not known, you can use "WebDriver.getWindowHandles()" to obtain a list of known windows. You may pass the handle to "switchTo().window()".

=== Q: Does WebDriver support Javascript alerts and prompts? ===

A: Not yet, but we plan on adding an API for this, that will look something like:

{{{
// Get a handle to the open alert, prompt or confirmation
Alert alert = driver.switchTo().alert();
// Get the text of the alert or prompt
alert.getText();  
// And acknowledge the alert (equivalent to clicking "OK")
alert.accept();
}}}

=== Q: The "onchange" event doesn't fire after a call "sendKeys" ===

A: WebDriver leaves the focus in the element you called "sendKeys" on. The "onchange" event will only fire when focus leaves that element. As such, you need to move the focus, perhaps using a "click" on another element.

=== Q: Can I run multiple instances of the WebDriver sub-classes? ===

A: Each instance of HtmlUnit and FirefoxDriver is completely independent of every other instance (in the case of firefox, each instance has its own anonymous profile it uses).  See the ChromeDriver page for details of its concurrency (short answer: it's possible on Windows at the moment, but you need to apply a patch). Because of the way that Windows works, there should only ever be a single InternetExplorerDriver instance at one time. If you need to run more than one instance of the InternetExplorerDriver at a time, consider using the RemoteWebDriver and virtual machines.

=== Q: How do I handle authentication with the HtmlUnitDriver? ===

A: When creating your instance of the HtmlUnitDriver, override the "modifyWebClient" method, for example:

{{{
WebDriver driver = new HtmlUnitDriver() {
  protected WebClient modifyWebClient(WebClient client) {
    // This class ships with HtmlUnit itself
    DefaultCredentialsProvider creds = DefaultCredentialsProvider();

    // Set some example credentials
    creds.addCredentials("username", "password");

    // And now add the provider to the webClient instance
    client.setCredentialsProvider(creds);

    return client;
  }
};
}}}

=== Q: Is WebDriver thread-safe? ===

A: WebDriver is not thread-safe. Having said that, if you can serialise access to the underlying driver instance, you can share a reference in more than one thread. This is not advisable.

=== Q: How do I type into a contentEditable iframe? ===

A: Assuming that the iframe is named "foo":

{{{
driver.switchTo().frame("foo");
WebElement editable = driver.switchTo().activeElement();
editable.sendKeys("Your text here");
}}}

Sometimes this doesn't work, and this is because the iframe doesn't have any content. On Firefox you can execute the following before "sendKeys":

{{{
((JavascriptExecutor) driver).executeScript("document.body.innerHTML = '<br>'");
}}}

This is needed because the iframe has no content by default: there's nothing to send keyboard input to. This method call inserts an empty tag, which sets everything up nicely.

=== Q: WebDriver fails to start Firefox on Linux due to java.net.SocketException ===
If, when running WebDriver on Linux, Firefox fails to start and the error looks like:
{{{
Caused by: java.net.SocketException: Invalid argument
        at java.net.PlainSocketImpl.socketBind(Native Method)
        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)
        at java.net.Socket.bind(Socket.java:571)
        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)
        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)
}}}
It may be caused due to IPv6 settings on the machine. Execute:
{{{
sudo sysctl net.ipv6.bindv6only=0
}}}
To get the socket to bind both to IPv6 and IPv4 addresses of the host with the same calls.
More permanent solution is disabling this behaviour by editing /etc/sysctl.d/bindv6only.conf

=== Q: WebDriver fails to find elements / Does not block on page loads ===
This problem can manifest itself in various ways:
 * Using WebDriver.findElement(...) throws ElementNotFoundException, but the element is clearly there - inspecting the DOM (using Firebug, etc) clearly shows it. 
 * Calling Driver.get returns once the HTML has been loaded - but Javascript code triggered by the onload event was not done, so the page is incomplete and some elements cannot be found.
 * Clicking on an element / link triggers an operation that creates new element. However, calling findElement(s) after click returns does not find it. Isn't click supposed to be blocking?
 * How do I know when a page has finished loading?

Explanation:
WebDriver has a blocking API, generally. However, under some conditions it is possible for a get call to return before the page has finished loading. The classic example is Javascript starting to run after the page has loaded (triggered by onload). Browsers (e.g. Firefox) will notify WebDriver when the basic HTML content has been loaded, which is when WebDriver returns. It's difficult (if not impossible) to know when Javascript has finished executing, since JS code may schedule functions to be called in the future, depend on server response, etc. This is also true for clicking - when the platform supports native events (Windows, Linux) clicking is done by sending a mouse click event with the element's coordinates at the OS level - WebDriver cannot track the exact sequence of operations this click creates. For this reason, the blocking API is imperfect - WebDriver cannot wait for all conditions to be met before the test proceeds because it does not know them. Usually, the important matter is whether the element involved in the next interaction is present and ready.

Solution:
Use the Wait class to wait for a specific element to appear. This class simply calls findElement over and over, discarding the NoSuchElementException each time, until the element is found (or a timeout has expired). Since this is the behaviour desired by default for many users, a mechanism for  implicitly-waiting for elements to appear has been implemented. This is accessible through the [http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html WebDriver.manage().timeouts()] call. (This was previously tracked on issue [http://code.google.com/p/selenium/issues/detail?id=26 26]).

=== Q: How can I trigger arbitrary events on the page? ===
WebDriver aims to emulate user interaction - so the API reflects the ways a user can interact with various elements. 

Triggering a specific event cannot be achieved directly using the API, but one can use the Javascript execution abilities to call methods on an element.

=== Q: Why is it not possible to interact with hidden elements? ===
Since a user cannot read text in a hidden element, WebDriver will not allow access to it as well.

However, it is possible to use Javascript execution abilities to call getText directly from the element:
((JavascriptExecutor) driver).executeScript("return arguments[0].getText();", ...)

=== Q: How do I start Firefox with an extension installed? ===
{{{
FirefoxProfile profile = new FirefoxProfile()
profile.addExtension(....);

WebDriver driver = new FirefoxDriver(profile);
}}}

=== Q: I'd like it if WebDriver did.... ===

A: If there's something that you'd like WebDriver to do, or you've found a bug, then please add an [http://code.google.com/p/webdriver/issues/list add an issue] to the WebDriver project page.

=== Q: Why Is The InternetExplorerDriver Called Jobbie? ===

A: It started out as a play on "[http://jacobie.sourceforge.net jacobie]". It's not terribly funny, I know, but it made sense at the time and the name has stayed.

=== Q: Selenium server sometimes takes a long time to start a new session ? ===

A: If you're running on linux, you will need to increase the amount of entropy available for secure random number generation. Most linux distros can install a package called "randomsound" to do this.

On Windows (XP), you may be running into http://bugs.sun.com/view_bug.do?bug_id=6705872, which usually means clearing out a lot of files from your temp directory.
temp directory.