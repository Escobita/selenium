#summary Ruby bindings

= Introduction =

The Ruby bindings for the WebDriver API are available as the [http://rubygems.org/gems/selenium-webdriver selenium-webdriver] gem. 

The bindings support Ruby 1.8.7 through 1.9.1, JRuby and Rubinius.  

  * [http://selenium.googlecode.com/svn/trunk/docs/api/rb/index.html API docs]
  * [http://selenium.googlecode.com/svn/trunk/rb/CHANGES Changelog]

= API Example =

The bindings provide a slightly rubified version of the WebDriver API:

{{{
require "selenium-webdriver"

driver = Selenium::WebDriver.for :firefox
driver.navigate.to "http://google.com"

element = driver.find_element(:name, 'q')
element.send_keys "Hello WebDriver!"
element.submit

puts driver.title

driver.quit
}}}

The ruby bindings have drivers for Firefox, IE, Chrome and the remote server.

== IE ==

Make sure that Internet Options -> Security has the same Protected Mode setting (on or off, it doesn't matter as long as it is the same value) for all zones. 

== Remote ==

The RemoteWebDriver makes it easy to control a browser running on another machine. Download the jar (from [http://code.google.com/p/selenium/downloads/list Downloads]) and launch the server:

{{{java -jar selenium-server-standalone.jar}}}

Then connect to it from Ruby

{{{
driver = Selenium::WebDriver.for(:remote)
}}}

By default, this connects to the server running on localhost:4444 and opens Firefox. To connect to another machine, use the :url option:

{{{
driver = Selenium::WebDriver.for(:remote, :url => "http://myserver:4444/wd/hub")
}}}

To launch another browser, use the :desired_capabilities option:

{{{
driver = Selenium::WebDriver.for(:remote, :desired_capabilities => :chrome)
}}}

You can also pass an instance of Selenium::WebDriver::Remote::Capabilities, e.g.:

{{{
include Selenium

caps = WebDriver::Remote::Capabilities.htmlunit(:javascript_enabled => true)
driver = WebDriver.for(:remote, :desired_capabilities => caps)
}}}

You may want to set the proxy settings of the remote browser (this currently only works for firefox)

{{{
include Selenium

caps = WebDriver::Remote::Capabilities.firefox(:proxy => WebDriver::Proxy.new(:http => "myproxyaddress:8080"))
driver = WebDriver.for(:remote, :desired_capabilities => caps)
}}}

Or if you have a proxy in front of the remote server:

{{{
include Selenium

client = WebDriver::Remote::Http::Default.new
client.proxy = Proxy.new(:http => "http://proxy.org:8080")

driver = WebDriver.for(:remote, :http_client => client)
}}} 

see [http://code.google.com/p/selenium/source/browse/trunk/rb/lib/selenium/webdriver/common/proxy.rb Selenium::WebDriver::Proxy] for more options

For the remote firefox driver you can configure the profile - See the section Tweaking Firefox preferences

== Firefox ==

The FirefoxDriver lets you configure the profile used.

=== Adding an extension ===

It's often useful to have Firebug available in the Firefox instance launched by WebDriver:

{{{
include Selenium

profile = WebDriver::Firefox::Profile.new
profile.add_extension("/path/to/firebug.xpi")

driver = WebDriver.for :firefox, :profile => profile
}}}

=== Using an existing profile === 

You can use an existing profile as a template for the WebDriver profile by passing the profile name (see `firefox -ProfileManager` to set up custom profiles.)

{{{
driver = Selenium::WebDriver.for(:firefox, :profile => "my-existing-profile")
}}}

=== Tweaking Firefox preferences ===

Use a proxy:

{{{
profile = Selenium::WebDriver::Firefox::Profile.new
proxy = Selenium::WebDriver::Proxy.new(:http => "http://proxy.org:8080")
profile.proxy = proxy

driver = Selenium::WebDriver.for :firefox, :profile => profile
}}}

Automatically download files to a given folder:

{{{
profile = Selenium::WebDriver::Firefox::Profile.new
profile['browser.download.dir'] = "/tmp/webdriver-downloads"
profile['browser.download.folderList'] = 2
profile['browser.helperApps.neverAsk.saveToDisk'] = "application/pdf"

driver = Selenium::WebDriver.for :firefox, :profile => profile
}}}

If you are using the remote driver you can still configure the firefox profile:

{{{
profile = Selenium::WebDriver::Firefox::Profile.new
profile['foo.bar'] = true
  
capabilities = Selenium::WebDriver::Remote::Capabilities.firefox(:firefox_profile => profile)
driver = Selenium::WebDriver.for :remote, :desired_capabilities => capabilities
}}}

=== Custom Firefox path ===

If your Firefox executable is in a non-standard location:

{{{
Selenium::WebDriver::Firefox.path = "/path/to/firefox"
driver = Selenium::WebDriver.for :firefox
}}}

=== Native events ===

Native events are enabled by default on Windows. To turn them off:

{{{
profile = Selenium::WebDriver::Firefox::Profile.new
profile.native_events = false

driver = Selenium::WebDriver.for(:firefox, :profile => profile)
}}}

Experimental support for native events is available on Linux. Set {{{profile.native_events = true}}} to turn this on.

== Timeouts ==

=== Implicit waits ===

WebDriver lets you configure implicit waits, so that a call to #find_element will wait for a specified amount of time before raising a NoSuchElementError:

{{{
  driver = Selenium::WebDriver.for :firefox
  driver.manage.timeouts.implicit_wait = 3 # seconds
}}}

=== Internal timeouts ===

Internally, WebDriver uses HTTP to communicate with a lot of the drivers (the JsonWireProtocol). By default, Net::HTTP from Ruby's standard library is used, which has a default timeout of 60 seconds. If you call Driver#get on a page that takes more than 60 seconds to load, you'll see a TimeoutError raised from Net::HTTP. You can configure this timeout (before launching a browser) by doing:

{{{
  client = Selenium::WebDriver::Remote::Http::Default.new
  client.timeout = 120 # seconds
  driver = Selenium::WebDriver.for(:remote, :http_client => client)
}}}


== Javascript Alert/Confirm ==

You can use webdriver to handle javascript alert and confirm dialogs.
The implementation for both is the same.

Note: At this time the API is only available in Firefox (or in Firefox using the remote server), and only alert/confirms that are generated post load can be captured. 

{{{
require "selenium-webdriver"

driver = Selenium::WebDriver.for :firefox
driver.navigate.to "http://mysite.com/page_with_alert.html"

driver.find_element(:name, 'element_with_alert_javascript').click
a = driver.switch_to.alert
if a.text == 'A value you are looking for'
  a.dismiss
else
  a.accept
end

}}}

== Using Curb or your own HTTP client ==

For internal HTTP communication, Net::HTTP is used by default. If you e.g. have the [https://rubygems.org/gems/curb Curb gem] installed, you can switch to it by doing:

{{{
require 'selenium/webdriver/remote/http/curb'
include Selenium

client = WebDriver::Remote::Http::Curb.new
driver = WebDriver.for(:firefox, :http_client => client)
}}}

If you have the [https://github.com/drbrain/net-http-persistent net-http-persistent gem] installed, you can (as of 0.1.3) similarly use "selenium/webdriver/remote/http/persistent" to get keep-alive connections. This will significantly reduce the ephemeral ports usage of WebDriver, which is useful in [ScalingWebdriver some contexts]. Note that this currently only works with the remote Java server (the other servers doesn't yet support keep-alive). 