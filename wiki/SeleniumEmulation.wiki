#summary Emulating Selenium
#labels WebDriver

= Selenium Emulation =

The Java version of WebDriver provides an implementation of the existing Selenium API. It is used like so:

{{{
// You may use any WebDriver implementation. Firefox is used here as an example
WebDriver driver = new FirefoxDriver();

// A "base url", used by selenium to resolve relative URLs
String baseUrl = "http://www.google.com";

// Create the Selenium implementation
Selenium selenium = new WebDriverBackedSelenium(driver, baseUrl);

// Perform actions with selenium
selenium.open("http://www.google.com");
selenium.type("name=q", "cheese");
selenium.click("name=btnG");

// And get the underlying WebDriver implementation back. This will refer to the
// same WebDriver instance as the "driver" variable above.
WebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getUnderlyingWebDriver();
}}}

== Pros ==

  * Allows for WebDriver and Selenium to live side-by-side.
  * Provides a simple mechanism for a managed migration from the existing Selenium API to WebDriver's.
  * Does not require the standalone Selenium RC server to be run

== Cons ==

  * Does not implement every method
    * But we'd love feedback!
  * Does also emulate Selenium Core
    * So more advanced Selenium usage (that is, using "browserbot" or other built-in Javascript methods from Selenium Core) may need work
  * Some methods may be slower due to underlying implementation differences

== Notes ==
After creating a `WebDriverBackedSelenium` instance with a given Driver, one does not have to call `start()` - as the creation of the Driver already started the session. At the end of the test, `stop()` should be called *instead* of the Driver's `quit()` method.

This is more similar to WebDriver's behaviour - as creating a Driver instance starts a session, yet it has to be terminated explicitly with a call to `quit()`.

== Backing WebDriver with Selenium == 

WebDriver doesn't support as many browsers as Selenium does, so in order to provide that support while still using the webdriver API, you can make use of the {{{SeleneseCommandExecutor}}} It is done like this:

{{{
Capabilities capabilities = new DesiredCapabilities()
capabilities.setBrowserName("safari");
CommandExecutor executor = new SeleneseCommandExecutor("http:localhost:4444/", "http://www.google.com/", capabilities);
WebDriver driver = new RemoteWebDriver(executor, capabilities);
}}}

There are currently some major limitations with this approach, notably that `findElements` doesn't work as expected. Also, because we're using Selenium Core for the heavy lifting of driving the browser, you are limited by the Javascript sandbox. 