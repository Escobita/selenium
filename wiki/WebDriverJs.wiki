#summary WebDriver's JavaScript language bindings.
#labels WebDriver,JavaScript

= WebDriverJS =
<wiki:toc max_depth=3/>

== Introduction ==

The !JavaScript bindings for !WebDriver (WebDriverJS) are designed to allow !JavaScript developers to avoid costly context switches and to write their end-to-end tests in the same language as their production code.  Designed as a library for use anywhere !JavaScript is available, WebDriverJS can be deployed in either a server-side environment, such as [#Node node], or a [#In_the_Browser browser].

*Warning*: WebDriverJS is targeted at developers comfortable with asynchronous programming. Users new to !JavaScript may find WebDriverJS difficult to work with.

== Getting Started ==

Compile a single !JavaScript module, which may be deployed in either node or the browser, by running

{{{
$ ./go webdriverjs
}}}

=== Node ===

While WebDriverJS may be used in node, it currently does not have native driver support (eg, you can only write tests against a remote !WebDriver server). Thus, in addition to `webdriverjs`, you must also compile `selenium-server-standalone`:

{{{
$ ./go selenium-server-standalone webdriverjs
}}}

Once both targets have compiled, start the server, launch node, and start writing tests:

{{{
$ java -jar build/java/server/src/org/openqa/selenium/server/server-standalone.jar &
$ node
> var webdriver = require('./build/javascript/webdriver-jsapi/webdriver');
> var driver = new webdriver.Builder().
    usingServer('http://localhost:4444/wd/hub').
    withCapabilities({
      'browserName': 'chrome',
      'version': '',
      'platform': 'ANY',
      'javascriptEnabled': true
    }).
    build();
> driver.get('http://www.google.com');
> driver.findElement(By.name('q')).sendKeys('webdriver');
> driver.findElement(By.name('btnG')).click();
> driver.getTitle().then(function(title) {
  require('assert').equal('webdriver - Google Search', title);
});
}}}

=== In the Browser ===

In addition to node, WebDriverJS may also be used directly in the browser. When running in a browser, WebDriverJS communicates with the !WebDriver server using the same [JsonWireProtocol protocol] as the other language bindings. While the !WebDriver client is not bound by a security sandbox when running in node, it will be bound by the [http://www.google.com/url?q=http://www.w3.org/Security/wiki/Same_Origin_Policy same origin policy] in a browser. In order to communicate with a !WebDriver server which may be on a different domain, the client will select the most appropriate mechanism based on the capabilities of the current browser: [#Cross-Origin_Resource_Sharing cross-origin resource sharing] or [#JSONP JSONP]. This selection is handled by the `Builder`:

{{{
<!DOCTYPE html>
<script src="webdriver.js"></script>
<script>
  var driver = new webdriver.Builder().
      usingServer('http://localhost:4444/wd/hub').
      withCapabilities({
        'browserName': 'chrome',
        'version': '',
        'platform': 'ANY',
        'javascriptEnabled': true
      }).
      build();

  driver.get('http://www.google.com');
  driver.findElement(By.name('q')).sendKeys('webdriver');
  driver.findElement(By.name('btnG')).click();
  driver.getTitle().then(function(title) {
    if (title !== 'webdriver - Google Search') {
      throw new Error(
          'Expected "webdriver - Google Search", but was "' + title + '"');
    }
  });
</script>
}}}

One of the advantages to running WebDriverJS in the browser is that WebDriverJS can control the browser running the script, as long as the URL for the server and session ID for the browser are known. While the URL and session may be passed to the builder directly, they may also be defined using the `wdurl` and `wdsid` "environment variables", which are parsed from the loading page's URL query data:

{{{
<!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&wdsid=foo1234 -->
<!DOCTYPE html>
<script src="webdriver.js"></script>
<input id="input" type="text"/>
<script>
  var driver = new webdriver.Builder().build();
  var input = driver.findElement(By.tagName('input'));
  input.sendKeys('foo bar baz').then(function() {
    assertEquals('foo bar baz',
        document.getElementById('input').value);
  });
</script>
}}}

You can debug a WebDriverJS test in the browser using !WebDriver's stand alone server:

{{{
$ ./go selenium-server-standalone
$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &
}}}

After starting the server, open a browser to the !WebDriver control panel: `http://localhost:4444/wd/hub`.  You can use this control panel to view, create, or delete sessions on the server.  After selecting a session to use for debugging, click the `Load Script` button. In the pop-up dialog, enter the URL for your WebDriverJS test: the server will open that page in your browser with the additional parameters necessary for a WebDriverJS client to communicate with the server.

==== Supported Browsers ====

WebDriverJS is supported in the following browsers:
 * IE 8+
 * Firefox 3.6+
 * Chrome 12+
 * Opera 11.51+
 * Android 4.0+

== Design Details ==

=== Managing an Asynchronous API ===

Unlike the other language bindings, which all provide blocking APIs, WebDriverJS is purely asynchronous. In order to track the state of each command, WebDriverJS makes extensive use of "promises". A promise is an object which represents a value that will be made available at some point in the future.  While there are various promise implementations for !JavaScript, the WebDriverJS promise is based on the [http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&sa=D&sntz=1&usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw Promise/A] proposal from CommonJS, which defines a promise as any object with a `then` function property:

{{{
/**
 * Registers listeners for when this instance is resolved.
 *
 * @param {?function(*)} callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {?function(*)=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the failure
 *     reason. While this argument is typically an {@code Error}, any type is
 *     permissible.
 * @return {!Promise} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
Promise.prototype.then = function(callback, opt_errback) {
};
}}}

Using promises, users can string together a sequence of asynchronous actions, ensuring that each executes once the one before it has finished:

{{{
var driver = new webdriver.Builder().build();
driver.get('http://www.google.com').then(function() {
  return driver.findElement(By.name('q')).then(function(searchBox){
    return searchBox.sendKeys('webdriver').then(function() {
      return driver.findElement(By.name('btnG')).then(function(submitButton) {
        return submitButton.click().then(function() {
          return driver.getTitle().then(function(title) {
            assertEquals('webdriver - Google Search', title);
          });
        });
      });
    });
  });
});
}}}

Unfortunately, the example above is excessively verbose, making it hard to easily discern the test's intent. In order to provide an API that cleanly handles asynchronous actions _without impeding test readability_, WebDriverJS introduces a promise "manager" to coordinate the scheduling and execution of all commands.

Simply put, the promise manager handles the scheduling and execution of user defined tasks. The manager maintains a queue of scheduled tasks, executing each as the task before it in the queue finishes. If a task returns a promise, the manager will register itself as a callback and resume its run-loop when the promise is resolved.  !WebDriver will use the manager automatically, so users don't need to worry about chaining their commands together.  Thus, the previous Google search example can be simplified:

{{{
var driver = new webdriver.Builder().build();
driver.get('http://www.google.com');

var searchBox = driver.findElement(By.name('q'));
searchBox.sendKeys('webdriver');

var submitButton = driver.findElement(By.name('btnG'));
submitButton.click();

driver.getTitle().then(function(title) {
  assertEquals('webdriver - Google Search', title);
});
}}}

==== On Frames and Callbacks ====

Internally, the promise manager maintains a call stack. Upon each turn of the manager's execution loop, it will pull a task to execute from the queue of the top-most frame. Any commands scheduled within the callback of a previous command will be scheduled in a new frame, ensuring they run before any tasks previously scheduled. The end result is that if your test is written-in line, with all callbacks defined by function literals, commands should execute in the order they are read vertically on the screen. For example, consider the following WebDriverJS test case:

{{{
driver.get(MY_APP_URL);
driver.getTitle().then(function(title) {
  if (title === 'Login page') {
    driver.findElement(By.id('user')).sendKeys('bugs');
    driver.findElement(By.id('pw')).sendKeys('bunny');
    driver.findElement(By.id('login')).click();
  }
});
driver.findElement(By.id('userPreferences')).click();
}}}

This test case could be rewritten using !WebDriver's Java API as follows:

{{{
driver.get(MY_APP_URL);
if (driver.getTitle().equals("Login Page")) {
  driver.findElement(By.id("user")).sendKeys("bugs");
  driver.findElement(By.id("pw")).sendKeys("bunny");
  driver.findElement(By.id("login")).click();
}
driver.findElement(By.id("userPreferences")).click();
}}}


==== Error Handling ====

Since every WebDriverJS action executes asynchronously, you cannot use try-catch blcoks. Instead, you must register _errbacks_ on the promised result of teh command in question. Each errback may either throw another Error, in which case it will be passed to the next errback in the chain or it may return a different value to suppress the error and switch back to the callback processing chain.

If a rejected promise (not just those from !WebDriver commands) is not handled by an errback handler, that error will propagate to the parent frame's errback chain. If an error makes its way to the top frame without being suppressed, the promise manager will dispatch an `uncaughtException` event, discarding all other commands that have been queued:

{{{
driver.switchTo().window('foo').then(null, function(e) {
  // Ignore NoSuchWindow errors. Let any others bubble up.
  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {
    throw e;
  }
});
// This will never execute if the error above is not suppressed.
driver.getTitle();
}}}

=== Communicating with the Server ===

WebDriverJS communicates with the !WebDriver server using the same [JsonWireProtocol protocol] as the other language bindings. When running in a server-side environment, the client is not bound by a security sandbox and may use a simple HTTP client to send commands (eg, node's [http://nodejs.org/docs/v0.6.0/api/http.html#http.ClientRequest http.ClientRequest]). When running inside a browser, however, the WebDriverJS client will be bound by the [http://www.w3.org/Security/wiki/Same_Origin_Policy same origin policy]. In order to communicate with a server which may be on a different domain, the client will select the most appropriate mechanism based on the capabilities of the current browser: cross-origin resource sharing or JSONP.

==== Cross-Origin Resource Sharing ====

If a browser supports [http://www.w3.org/TR/cors/ cross-origin resource sharing] (CORS), WebDriverJS will use cross-origin XMLHttpRequests to send commands to the server. Servers that wish to support WebDriverJS via CORS must respond to preflight requests (identified by requests with an `Origin` header) with the appropriate access-control headers:

{{{
Access-Control-Origin: *
Access-Control-Allow-Methods: DELETE,GET,HEAD,POST
Access-Control-Allow-Headers: Accept,Content-Type
}}}

As of this writing, CORS is supported by Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, and Android 2.1+.  While IE8 and IE9 partially support CORS using the [http://www.google.com/url?q=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fcc288060(v%3Dvs.85).aspx&sa=D&sntz=1&usg=AFQjCNFAy9IwwS1SmIYBIogaHo3rD96-Nw XDomainRequest] object, it is, by design, [http://www.google.com/url?q=http%3A%2F%2Fblogs.msdn.com%2Fb%2Fieinternals%2Farchive%2F2010%2F05%2F13%2Fxdomainrequest-restrictions-limitations-and-workarounds.aspx&sa=D&sntz=1&usg=AFQjCNF5quaFXbf77M4mCa-3c2XRDexVsA less capable] than its XMLHttpRequest counterpart. The XDomainRequest is only capable of sending requests that could be sent by a standard HTML form. This limits IE to sending GET and POST requests (the wire protocol requires support for DELETE requests).  Furthermore, the wire protocol dictates that [JsonWireProtocol#Failed_Commands command failures] be returned to the client as HTTP/1.1 500 responses, with the failure details encoded in a JSON message. Upon receiving a 500 response, the XDomainRequest object would fire its onerror handler, but without the details returned by the server. For these reasons, with respect to WebDriverJS, IE is considered to _not_ support CORS.

==== JSONP ====

In order to support browsers without CORS (ie, IE and Opera), a non-standard command shall be added to the [JsonWireProtocol JSON wire protocol]. This command, which is summarized below, need only be implemented by servers that wish to support WebDriverJS via JSONP.

----
<dl>
<dd>
==== GET /jsonp ====
</dd>
<dd>
<dl>
<dd>Serves as a proxy for another command, which shall be encoded in the query data for this command. The encoded command's result shall be returned to the client as a !JavaScript snippet that invokes the specified global callback function.</dd>
<dd>
<dl>
<dt>*Query Parameters:*</dt>
<dd>`method` - The HTTP method for the encoded command.</dd>
<dd>`path` - The path for the command.</dd>
<dd>`body` - A stringified JSON object with the parameters for the encoded command This may be omitted for non-POST commands.</dd>
<dd>`callback` - The name of the global !JavaScript function that should be invoked with the command response.</dd>
</dl>
</dd>
<dd>
<dl>
<dt>*Returns:*</dt>
<dd>`{string}` A !JavaScript snippet that invokes the command `callback` with the encoded command's [JsonWireProtocol#Responses JSON response].</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
----

As an example, consider the following `/jsonp` command:

{{{
GET /jsonp?method=POST&path=/session/123/element/0a/element&body={"using":"id","value":"foo"}&callback=myCallback HTTP/1.1
Accept: */*
}}}

The JSONP handler should decode this command and re-dispatch it as:

{{{
POST /session/123/element/0a/element HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28

{"using":"id","value":"foo"}
}}}

The JSONP handler would intercept the response and return it to the client as a !JavaScript invocation instead of pure JSON:

{{{
HTTP/1.1 200 OK
Content-Type: text/javascript
Content-Length: 51

myCallback({"status":0,"value":{"ELEMENT":"1fa"}});
}}}

==== Command Caching ====

Any GET-based command sent by a browser-based WebDriverJS client will be susceptible to undesired caching. To prevent this, the client should append a "cache-buster" to each request URL (`'cacheBuster=' + new Date().getTime()`). Likewise, WebDriverJS-compatible servers should include no-cache directives on all GET responses.

{{{
Cache-Control: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
}}}

== Future Work ==

Below are some of the projects we have envisioned using WebDriverJS.  When these will come to fruition, if ever, is unknown at this point.  If you're interested in contributing, drop us a line at selenium-developers@googlegroups.com.  Of course, this is open source software -- there's no need to wait for us.  If you've got an idea, start hacking!

 * Implement a pure-!JavaScript command executor using the AutomationAtoms. This will allow developers to write light weight tests in pure JS and run them on any browser (albeit, bound by the same origin policy).
 * Build an extension-based !SafariDriver.
 * Provide native browser support for node instead of requiring an external !WebDriver server