#summary WebDriver's JavaScript language bindings.
#labels WebDriver,JavaScript

= WebDriverJS =
<wiki:toc max_depth=3/>

== Introduction ==

The !JavaScript bindings for !WebDriver (WebDriverJS) are designed to allow !JavaScript developers to avoid costly context switches and to write their end-to-end tests in the same language as their production code.  Designed as a library for use anywhere !JavaScript is available, WebDriverJS can be deployed in either a server-side environment, such as [#Node node], or a [#In_the_Browser browser].

*Warning*: WebDriverJS is targeted at developers comfortable with asynchronous programming. Users new to !JavaScript may find WebDriverJS difficult to work with.

== Getting Started ==

Compile a single !JavaScript module, which may be deployed in either node or the browser, by running

{{{
$ ./go webdriverjs
}}}

=== Node ===

While WebDriverJS may be used in node, it currently does not have native driver support (eg, you can only write tests against a remote !WebDriver server). Thus, in addition to `webdriverjs`, you must also compile `selenium-server-standalone`:

{{{
$ ./go selenium-server-standalone webdriverjs
}}}

Once both targets have compiled, start the server, launch node, and start writing tests:

{{{
$ java -jar build/java/server/src/org/openqa/selenium/server/server-standalone.jar &
$ node
> var webdriver = require('./build/javascript/webdriver/webdriver');
> var driver = new webdriver.Builder().
    usingServer('http://localhost:4444/wd/hub').
    withCapabilities({
      'browserName': 'chrome',
      'version': '',
      'platform': 'ANY',
      'javascriptEnabled': true
    }).
    build();
> driver.get('http://www.google.com');
> driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
> driver.findElement(webdriver.By.name('btnG')).click();
> driver.getTitle().then(function(title) {
  require('assert').equal('webdriver - Google Search', title);
});
}}}

=== In the Browser ===

In addition to node, WebDriverJS may also be used directly in the browser.  In order to communicate with a !WebDriver server which may be on a different domain, the client uses a modified version of the JsonWireProtocol and [#Cross-Origin_Resource_Sharing cross-origin resource sharing]:

{{{
<!DOCTYPE html>
<script src="webdriver.js"></script>
<script>
  var driver = new webdriver.Builder().
      usingServer('http://localhost:4444/wd/hub').
      withCapabilities({
        'browserName': 'chrome',
        'version': '',
        'platform': 'ANY',
        'javascriptEnabled': true
      }).
      build();

  driver.get('http://www.google.com');
  driver.findElement(By.name('q')).sendKeys('webdriver');
  driver.findElement(By.name('btnG')).click();
  driver.getTitle().then(function(title) {
    if (title !== 'webdriver - Google Search') {
      throw new Error(
          'Expected "webdriver - Google Search", but was "' + title + '"');
    }
  });
</script>
}}}

One of the advantages to running WebDriverJS in the browser is that WebDriverJS can control the browser running the script, as long as the URL for the server and session ID for the browser are known. While the URL and session may be passed to the builder directly, they may also be defined using the `wdurl` and `wdsid` "environment variables", which are parsed from the loading page's URL query data:

{{{
<!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&wdsid=foo1234 -->
<!DOCTYPE html>
<script src="webdriver.js"></script>
<input id="input" type="text"/>
<script>
  var driver = new webdriver.Builder().build();
  var input = driver.findElement(By.tagName('input'));
  input.sendKeys('foo bar baz').then(function() {
    assertEquals('foo bar baz',
        document.getElementById('input').value);
  });
</script>
}}}

You can debug a WebDriverJS test in the browser using !WebDriver's stand alone server:

{{{
$ ./go selenium-server-standalone
$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &
}}}

After starting the server, open a browser to the !WebDriver control panel: `http://localhost:4444/wd/hub`.  You can use this control panel to view, create, or delete sessions on the server.  After selecting a session to use for debugging, click the `Load Script` button. In the pop-up dialog, enter the URL for your WebDriverJS test: the server will open that page in your browser with the additional parameters necessary for a WebDriverJS client to communicate with the server.

==== Supported Browsers ====

WebDriverJS is supported in the following browsers:
 * IE 8+
 * Firefox 4+
 * Chrome 12+
 * Opera 12.0a+
 * Android 4.0+

== Design Details ==

=== Managing an Asynchronous API ===

Unlike the other language bindings, which all provide blocking APIs, WebDriverJS is purely asynchronous. In order to track the state of each command, WebDriverJS makes extensive use of "promises". A promise is an object which represents a value that will be made available at some point in the future.  While there are various promise implementations for !JavaScript, the WebDriverJS promise is based on the [http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&sa=D&sntz=1&usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw Promise/A] proposal from CommonJS, which defines a promise as any object with a `then` function property:

{{{
/**
 * Registers listeners for when this instance is resolved.
 *
 * @param {?function(*)} callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {?function(*)=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the failure
 *     reason. While this argument is typically an {@code Error}, any type is
 *     permissible.
 * @return {!Promise} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
Promise.prototype.then = function(callback, opt_errback) {
};
}}}

Using promises, users can string together a sequence of asynchronous actions, ensuring that each executes once the one before it has finished:

{{{
var driver = new webdriver.Builder().build();
driver.get('http://www.google.com').then(function() {
  return driver.findElement(By.name('q')).then(function(searchBox){
    return searchBox.sendKeys('webdriver').then(function() {
      return driver.findElement(By.name('btnG')).then(function(submitButton) {
        return submitButton.click().then(function() {
          return driver.getTitle().then(function(title) {
            assertEquals('webdriver - Google Search', title);
          });
        });
      });
    });
  });
});
}}}

Unfortunately, the example above is excessively verbose, making it hard to easily discern the test's intent. In order to provide an API that cleanly handles asynchronous actions _without impeding test readability_, WebDriverJS introduces a promise "manager" to coordinate the scheduling and execution of all commands.

Simply put, the promise manager handles the scheduling and execution of user defined tasks. The manager maintains a queue of scheduled tasks, executing each as the task before it in the queue finishes. If a task returns a promise, the manager will register itself as a callback and resume its run-loop when the promise is resolved.  !WebDriver will use the manager automatically, so users don't need to worry about chaining their commands together.  Thus, the previous Google search example can be simplified:

{{{
var driver = new webdriver.Builder().build();
driver.get('http://www.google.com');

var searchBox = driver.findElement(By.name('q'));
searchBox.sendKeys('webdriver');

var submitButton = driver.findElement(By.name('btnG'));
submitButton.click();

driver.getTitle().then(function(title) {
  assertEquals('webdriver - Google Search', title);
});
}}}

==== On Frames and Callbacks ====

Internally, the promise manager maintains a call stack. Upon each turn of the manager's execution loop, it will pull a task to execute from the queue of the top-most frame. Any commands scheduled within the callback of a previous command will be scheduled in a new frame, ensuring they run before any tasks previously scheduled. The end result is that if your test is written-in line, with all callbacks defined by function literals, commands should execute in the order they are read vertically on the screen. For example, consider the following WebDriverJS test case:

{{{
driver.get(MY_APP_URL);
driver.getTitle().then(function(title) {
  if (title === 'Login page') {
    driver.findElement(By.id('user')).sendKeys('bugs');
    driver.findElement(By.id('pw')).sendKeys('bunny');
    driver.findElement(By.id('login')).click();
  }
});
driver.findElement(By.id('userPreferences')).click();
}}}

This test case could be rewritten using !WebDriver's Java API as follows:

{{{
driver.get(MY_APP_URL);
if (driver.getTitle().equals("Login Page")) {
  driver.findElement(By.id("user")).sendKeys("bugs");
  driver.findElement(By.id("pw")).sendKeys("bunny");
  driver.findElement(By.id("login")).click();
}
driver.findElement(By.id("userPreferences")).click();
}}}


==== Error Handling ====

Since every WebDriverJS action executes asynchronously, you cannot use try-catch blcoks. Instead, you must register _errbacks_ on the promised result of teh command in question. Each errback may either throw another Error, in which case it will be passed to the next errback in the chain or it may return a different value to suppress the error and switch back to the callback processing chain.

If a rejected promise (not just those from !WebDriver commands) is not handled by an errback handler, that error will propagate to the parent frame's errback chain. If an error makes its way to the top frame without being suppressed, the promise manager will dispatch an `uncaughtException` event, discarding all other commands that have been queued:

{{{
driver.switchTo().window('foo').then(null, function(e) {
  // Ignore NoSuchWindow errors. Let any others bubble up.
  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {
    throw e;
  }
});
// This will never execute if the error above is not suppressed.
driver.getTitle();
}}}

=== Communicating with the Server ===

When running in a server-side environment, the client is not bound by a security sandbox and may use a simple HTTP client to send commands (eg, node's [http://nodejs.org/docs/v0.6.0/api/http.html#http.ClientRequest http.ClientRequest]). When running inside a browser, however, the WebDriverJS client will be bound by the [http://www.w3.org/Security/wiki/Same_Origin_Policy same origin policy]. In order to communicate with a server which may be on a different domain, the WebDriverJS client will use a modified version of the JsonWireProtocol and cross-origin resource sharing.

==== Cross-Origin Resource Sharing ====

If a browser supports [http://www.w3.org/TR/cors/ cross-origin resource sharing] (CORS), WebDriverJS will use cross-origin XMLHttpRequests to send commands to the server. Servers that wish to support WebDriverJS via CORS must respond to preflight requests (identified by `OPTIONS` requests with an `Origin` header) with the appropriate access-control headers:

{{{
Access-Control-Origin: *
Access-Control-Allow-Methods: DELETE,GET,HEAD,POST
Access-Control-Allow-Headers: Accept,Content-Type
}}}

As of this writing, CORS is supported by Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, and Android 2.1+, Opera 12.0a, and IE8+.  Unfortunately, the various browser's implementations are inconsistent and not all adhere to the W3C specification.
 * IE's [http://www.google.com/url?q=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fcc288060(v%3Dvs.85).aspx&sa=D&sntz=1&usg=AFQjCNFAy9IwwS1SmIYBIogaHo3rD96-Nw XDomainRequest] object is, by design, [http://www.google.com/url?q=http%3A%2F%2Fblogs.msdn.com%2Fb%2Fieinternals%2Farchive%2F2010%2F05%2F13%2Fxdomainrequest-restrictions-limitations-and-workarounds.aspx&sa=D&sntz=1&usg=AFQjCNF5quaFXbf77M4mCa-3c2XRDexVsA less capable] than its XMLHttpRequest counterpart. The XDomainRequest is only capable of sending requests that could be sent by a standard HTML form. This limits IE to sending GET and POST requests (the wire protocol requires support for DELETE requests).
 * WebKit's implementation of CORS currently forbids redirects on cross-domain requests, even if the access-control headers are properly set.
 * If the server returns an error response (4xx or 5xx), IE and Opera's implementations will fire the XDomainRequest/XMLHttpRequest object's onerror handler, but without the text of the server's response. This renders IE and Opera incapable of handling failures in the standard JSON protocol.

To compensate for these short-comings, when running in a browser, WebDriverJS will use a modified version of the JsonWireProtocol and route all commands through the `/xdrpc` end-point.

----
<dl>
<dd>
==== POST /xdrpc ====
</dd>
<dd>
<dl>
<dd>Serves as a proxy for another command, which shall be encoded in the JSON body for this command.  The encoded command's result shall always be returned as a standard [JsonWireProtocol#Responses response] object in a HTTP 200 response. Client's must rely on the response's `status` field to determine whether the command [JsonWireProtocol#Response_Status_Codes succeeded].</dd>
<dd>
<dl>
<dt>*JSON Parameters:*</dt>
<dd>`method` - `{string}` The HTTP method for the encoded command.</dd>
<dd>`path` - `{string}` The path for the command.</dd>
<dd>`data` - `{Object}` The JSON parameters for the encoded command.</dd>
</dl>
</dd>
<dd>
<dl>
<dt>*Returns:*</dt>
<dd>`{*}` The command result.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
----

As an example, consider the following `/xdrpc` command:

{{{
POST /xdrpc HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 94

{"method":"POST","path":"/session/123/element/0a/element","data":{"using":"id","value":"foo"}}
}}}

The server should decode this command and re-dispatch it as:

{{{
POST /session/123/element/0a/element HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28

{"using":"id","value":"foo"}
}}}

The command's response would be returned as a standard JSON response, even if it failed:

{{{
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 60

{"status":7,"value":{"message":"Unable to locate element."}}
}}}

== Future Work ==

Below are some of the projects we have envisioned using WebDriverJS.  When these will come to fruition, if ever, is unknown at this point.  If you're interested in contributing, drop us a line at selenium-developers@googlegroups.com.  Of course, this is open source software -- there's no need to wait for us.  If you've got an idea, start hacking!

 * Implement a pure-!JavaScript command executor using the AutomationAtoms. This will allow developers to write light weight tests in pure JS and run them on any browser (albeit, bound by the same origin policy).
 * Build an extension-based !SafariDriver.
 * Provide native browser support for node instead of requiring an external !WebDriver server